/**欧阳青星_20160103_《关于数字填空的编程题》 
题目：在横线上填写数字，使之符合要求。
  	0 1 2 3 4 5 6 7 8 9
  	_ _ _ _ _ _ _ _ _ _
	要求：对应的数字下填入的数，代表上面的数在下面出现的次数，比如3下面是1，代表3要在下面出现一次。

分析：这个题目乍看上去很简单，我第一想法是直接后面全部填0 然后0填8就可以了。
	但是仔细想想0下面填了8，那8不久出现了1次了吗？8下面就必须填1，这样0就不是8个了。
	这样会容易陷入死循环，不但难以找到正解，编程上更是无从下手。
	此时我想到了相似的游戏“数独”，我们知道数独是有一定规律的，即每一行每一列都只出现1-9数字一次。
	这个题一定有隐藏的规律，能让我们更方便的找到正解，并且方便编程实现。
	
	规律1：下面这些数字之和一定等于10。
	规律2：上下数字乘积之和为10。
	
	解释1：下面一排有且仅能填10个数字，所以无论这10数字是0-9怎样的组合而来，出现的次数只和一定等于10，即下面数字和为10.
	解释2：由规律1推倒而来，假设下面数字为0001112223,他们和为10，我们计算的方式为0*3 + 1*3 + 2*3 + 3*1 + 4*0 +5*0……9*0 = 10 ,式子的前半段即可总结为规律2。

	明白了这两个规律之后，问题就轻松了很多，我们只需要让计算机类似于解方程组那样去循环求解，即满足规律1规律2的数列就行了。

答案：0 1 2 3 4 5 6 7 8 9
    6 2 1 0 0 0 1 0 0 0
          */

package com.jason.best;

public class Oyqx_20160103 
{
	public static boolean checkArr(int[] arr)
	{
		if(arr[0]*0 + arr[1]*1+ arr[2]*2+ arr[3]*3+ arr[4]*4+ arr[5]*5+ arr[6]*6+ arr[7]*7+ arr[8]*8+ arr[9]*9 == 10)
		{
			return true;
		}
		return false;
	}
	
	public static int[] getArr()
	{
		int[] arr = {9,1,0,0,0,0,0,0,0,0}; 
		
		for(int i = 1 ;true ; i++)
		{
			//System.out.println(arr[2]);
			System.out.println(arr[0]+""+arr[1]+""+arr[2]+""+arr[3]+""+arr[4]+""+arr[5]+""+arr[6]+""+arr[7]+""+arr[8]+""+arr[9]);
			if(checkArr(arr))
			{
				break;
			}
			if(i == 9)
			{
				if(arr[1]==0 && arr[2]==0 && arr[3]==0 && arr[4]==0 && arr[5]==0 && arr[6]==0 && arr[7]==0 && arr[8]==0)
				{		
					arr[0] --;
					arr[1] = arr[9];
					arr[9] = 0;
					arr[1] ++;
					i = 1;
				}
				else
				{
					i = 0;
				}
			}
			else
			{	
				arr[i]--;System.out.println("i= "+ i);
				arr[i+1]++;
			} 
		}	
		return arr;
	}
	
	public static void main(String[] args)
	{
		int[] arr = getArr();
		System.out.println(arr[0]+arr[1]+arr[2]+arr[3]+arr[4]+arr[5]+arr[6]+arr[7]+arr[8]+arr[9]);
	}
}
